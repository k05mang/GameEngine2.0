package gldata;

import java.util.ArrayList;
import java.util.HashMap;

import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.opengl.GL45.*;
import glMath.matrices.Mat2;
import glMath.matrices.Mat3;
import glMath.matrices.Mat4;
import glMath.vectors.Vec2;
import glMath.vectors.Vec3;
import glMath.vectors.Vec4;
import renderers.RenderMode;
import core.Resource;

/**
 * Class for interacting with the gpu vertex array objects. This class is meant to handle the low level interfacing with
 * the gpu in creating vertex array objects and it's associated vertex buffers and index buffers.
 * 
 * The intended use of this class is to establish vertex attributes for the vertex array then perform the vertex buffer creation. 
 * This is so the stride of the data being read from the vertex buffer can be established when the vertex buffer is created
 * and bound to the vertex array.
 * 
 * @author Kevin Mango
 *
 */
public class VertexArray implements Resource{

	private int vaoId, stride, highestBufferIndex;
	private HashMap<String, Integer> bufferIndices;
	private HashMap<String, BufferObject> vbos;
	private HashMap<String, IndexBuffer> ibos;
	private HashMap<String, RenderMode> renderModes;
	private String ibo;
	private ArrayList<AttribType> attributes;
	
	/**
	 * Constructs an empty vertex array with an associated handle on the GPU
	 */
	public VertexArray(){
		//create the vao handle on the gpu
		vaoId = glCreateVertexArrays();
		//vertex buffer mapping to different names
		vbos = new HashMap<String, BufferObject>();
		//hashmap of index buffers
		ibos = new HashMap<String, IndexBuffer>();
		//hashmap correlating the rendermodes of the index buffers map
		renderModes = new HashMap<String, RenderMode>();
		ibo = null;//current index buffer to use
		stride = 0;//stride of the attribute
		
		//binding indices for the vertex buffers
		bufferIndices = new HashMap<String, Integer>();
		highestBufferIndex = 0;
		
		attributes = new ArrayList<AttribType>();//attributes associated with this vertex array
	}
	
	@Override
	public void delete(){
		//unbind the vertex array from the context
		glBindVertexArray(0);
		//delete the vertex array
		glDeleteVertexArrays(vaoId);
		
		//now delete the vertex and index buffers
		for(BufferObject buffer : vbos.values()){
			buffer.delete();
		}
		//delete index buffers
		for(IndexBuffer buffer : ibos.values()){
			buffer.delete();
		}
	}
	
	/**
	 * Gets the RenderMode that the vertex array currently is setup for
	 * 
	 * @return RenderMode this vertex array is currently setup for 
	 */
	public RenderMode getRenderMode(){
		return renderModes.get(ibo);
	}
	
	/**
	 * Gets the indexing type for the index buffer currently being used by the vertex array
	 * 
	 * @return IndexType of the currently bound index buffer
	 */
	public IndexBuffer.IndexType getIndexType(){
		return ibos.get(ibo).getType();
	}
	
	/**
	 * Gets the number of indices for the currently bound index buffer
	 * 
	 * @return Number of indices in the currently bound index buffer
	 */
	public int getNumIndices(){
		return ibos.get(ibo).numElements();
	}
	
	/**
	 * Gets the BufferObject associated with the given {@code name}
	 * 
	 * @param name Name of the buffer object to get
	 * @return BufferObject associated with the given {@code name} or null if it doesn't exist
	 */
	public BufferObject getVBO(String name){
		return vbos.get(name);
	}
	
	/**
	 * Gets the IndexBuffer associated with the given {@code id}
	 * 
	 * @param id Id of the index buffer to get
	 * @return IndexBuffer associated with the given {@code id} or null if it doesn't exist
	 */
	public IndexBuffer getIBO(String id){
		return ibos.get(id);
	}
	
	/**
	 * Generates a new Vertex buffer and assigns it the given {@code name}. The Vertex Buffer generated by this function
	 * is a {@code BufferObject} with a {@code BufferType} of {@code ARRAY}. If a Vertex Buffer already exists with the given
	 * name then the function will not create a new vertex buffer and will instead fail and return false.
	 * 
	 * @param name String id to associate with the new BufferObject
	 * @return True if the function succeeds in generating a new BufferObject with the given id, false otherwise
	 */
	public boolean genVBO(String name){
		//check to make sure the vbo doesn't already exist with the given name
		if(!vbos.containsKey(name)){
			//create the actual buffer object
			BufferObject vbo = new BufferObject(BufferType.ARRAY);

			//register this buffer object with the vertex array
			glVertexArrayVertexBuffer(vaoId, highestBufferIndex, vbo.getId(), 0, stride);
			//add this buffer object to the hashmap of buffer objects associated with this vertex array
			vbos.put(name, vbo);
			//mark this buffer object with the current highest buffer index
			bufferIndices.put(name, highestBufferIndex);
			//increment the buffer index
			highestBufferIndex++;
			return true;
		}
		return false;
	}
	
	/**
	 * Establishes a new binding index for the Vertex Buffer Specified by {@code name} in this Vertex Array.
	 * The new binding will use the latest stride value from the given attributes in establishing its binding.
	 * 
	 * @param name Name of the Vertex buffer in this Vertex array to bind to an index in the array
	 * @return True if the name exists, false otherwise
	 */
	public boolean registerVBO(String name){
		//check to make sure the buffer being set exists
		if(vbos.containsKey(name)){
			glVertexArrayVertexBuffer(vaoId, bufferIndices.get(name), vbos.get(name).getId(), 0, stride);
			return true;
		}else{
			return false;
		}
	}
	
	/**
	 * Creates a new Index buffer for this vertex array. The new index buffer will be associated with the given {@code id} 
	 * and RenderMode {@code mode}. If an existing Index buffer object is already assigned to the given id then this function
	 * will fail to generate an index buffer for the given id.
	 * 
	 * @param id ID this VertexArray will use to manipulate the given IndexBuffer
	 * @param mode RenderMode the given IndexBuffer will be mapped to
	 * @return True if the index buffer was successfully created and added to the vertex array, false otherwise
	 */
	public boolean genIBO(String id, RenderMode mode, IndexBuffer.IndexType indexType){
		if(!ibos.containsKey(id)){
			//create the new index buffer object
			IndexBuffer buffer = new IndexBuffer(indexType);
			//associate the buffer with the given id
			ibos.put(id, buffer);
			//associate the id with the given render mode
			renderModes.put(id, mode);
			return true;
		}
		return false;
	}
	
	/**
	 * Sets this VertexArray's IndexBuffer to the IndexBuffer with the given {@code id}, this will also specify 
	 * the current RenderMode for this VertexArray
	 * 
	 * @param id ID of the IndexBuffer to set as the active IndexBuffer of this VertexArray 
	 * @return True if there exists an IndexBuffer with the given id in this VertexArray, false otherwise
	 */
	public boolean setIndexBuffer(String id){
		//check to make sure the buffer being set exists
		if(ibos.containsKey(id)){
			//set the index buffer to the requested one
			ibo = id;
			//establish the index buffer at the gpu level
			glVertexArrayElementBuffer(vaoId, ibos.get(ibo).getId());
			return true;
		}else{
			return false;
		}
	}
	
	/**
	 * Adds an attribute definition for this vertex array
	 * 
	 * @param type The glsl attribute type that will define how the attribute will behave
	 * @param normalize Indicates whether the data being sent to the attribute should be normalized
	 * @param divisor Attribute divisor that decides the frequency of updating the attribute from the vertex buffer
	 */
	public void addAttrib(AttribType type, boolean normalize, int divisor){
		int baseIndex = attributes.size();
		//decompose the attribute and add it to the attributes list
		type.decompose(attributes);
		//set the attribute data, starting with the last index we had set
		for(int curIndex = baseIndex; curIndex <  attributes.size(); curIndex++){
			AttribType curType = attributes.get(curIndex);
			//decide what function to call based on the data type
			if(curType.isDouble()){
				glVertexArrayAttribLFormat(vaoId, curIndex, curType.size, curType.type, stride);
			}else if(curType.isFloat()){
				glVertexArrayAttribFormat(vaoId, curIndex, curType.size, curType.type, normalize, stride);
			}else{
				glVertexArrayAttribIFormat(vaoId, curIndex, curType.size, curType.type, stride);
			}
			stride += curType.bytes;
		}
	}
	
	/**
	 * Sets the Vertex buffer to use with the Attribute index in this array
	 * 
	 * @param attrib Index of the generic attribute array to bind
	 * @param vboName Name of the vbo in this vertex array to bind to the given attribute index
	 * @return True if the name of the vbo exists and was bound, false otherwise
	 */
	public boolean setAttribVBO(int attrib, String vboName){
		//check to make sure the buffer being set exists
		if(bufferIndices.containsKey(vboName)){
			glVertexArrayAttribBinding(vaoId, attrib, bufferIndices.get(vboName));
			return true;
		}else{
			return false;
		}
	}
	
	/**
	 * Binds this vertex array to the context
	 */
	public void bind(){
		glBindVertexArray(vaoId);
	}
	
	/**
	 * Unbinds this vertex array from the context
	 */
	public void unbind(){
		glBindVertexArray(0);
	}
	
	/**
	 * Enables a generic vertex array attribute for this vertex array object
	 * 
	 * @param attrib Index of the attribute array to enable
	 */
	public void enableAttribute(int attrib){
		glEnableVertexArrayAttrib(vaoId, attrib);
	}

	/**
	 * Disables a generic vertex array attribute for this vertex array object
	 * 
	 * @param attrib Index of the attribute array to disable
	 */
	public void disableAttribute(int attrib){
		glDisableVertexArrayAttrib(vaoId, attrib);
	}
}
